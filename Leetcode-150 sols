## Day 1
1 - ques : Merge Sorted Array 
- sol  : class Solution {
         public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // Append elements from nums2 to nums1
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        
        // Sort the combined array
        sort(nums1.begin(), nums1.end());
        }
     };



2- ques : Remove Element
- sol : class Solution {
         public:
         int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int ans = 0;
        for(int i = 0; i < n; i++){
            if(nums[i] != val){
                nums[ans] = nums[i];
                ans++;
            }
        }
        return ans;
         }
       };


3- ques : Remove Duplicates from Sorted Array
- sol : class Solution {
        public:
        int removeDuplicates(vector<int>& nums) {
        if(nums.empty()) return 0;
        int i = 0;
        for(int j = 0; j < nums.size();j++){
            if(nums[i] != nums[j]){
                i++;
            }
            nums[i] = nums[j];
        }
        return i + 1;
       }
    };

4 - ques :Remove Duplicates from Sorted Array II
- sol : class Solution {
         public:
        int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int i = 2;
        int j = 2;
        if( n < 3) return n;
        for(int j = 2; j < n;j++){
            if(nums[j] != nums[i - 1]){
                nums[i++] = nums[j];
            }
            else if(nums[j] != nums[i - 2]){
                nums[i++] = nums[j];
            }
        }
        return i;
       }
   };

5 - ques : Majority Element
- sol : class Solution {
        public:
        int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int x = nums[0];
        int v = 1;
        for(int i =1 ; i < n; i++){
            if(nums[i] == x){
                v++;
            }
            else{
                v--;
                if(v == 0){
                    x = nums[i];
                    v++;
                }
            }
        }
        return x;
         }
       };

6 - ques : Rotate Array
- sol : class Solution {
        public:
        void reverse(vector<int>& nums,int s,int e){
        while(s < e){
            swap(nums[s++],nums[e--]);
        }
    }
    void rotate(vector<int>& nums, int k) {
        // edge case 
        k = k % nums.size();
        // revrese all
        reverse(nums,0,nums.size() - 1);
        // reverse k 
        reverse(nums,0,k - 1);
        // reverse remaining
        reverse(nums,k,nums.size() - 1);
    }
  };

7 - ques : Best Time to Buy and Sell Stock
- sol : class Solution {
         public:
         int maxProfit(vector<int>& prices) {
        int profit = 0;
        int buy = prices[0];
        int n = prices.size();
        for(int i= 1; i <n; i++){
            if(buy > prices[i]){
                buy = prices[i];
            }
            profit = max(profit,prices[i] - buy);
        }
        return profit;
    }
};


8 - ques : Best Time to Buy and Sell Stock II
sol - : class Solution {
     public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        int n = prices.size();
        
        // Loop through the price list, check for each consecutive day.
        for (int i = 0; i < n - 1; i++) {
            // If the price of the next day is greater, add the difference to the profit.
            if (prices[i + 1] > prices[i]) {
                profit += prices[i + 1] - prices[i];
            }
        }
        
        return profit;
    }
};

9 - ques : Product of Array Except Self
sol - : class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
     int n = nums.size();
     vector< int> ans(n, 1); 

        //  Calculate prefix products
        int pre = 1;
        for (int i = 0; i < n; i++) {
            ans[i] = pre;
            pre *= nums[i];
        }

        // Calculate suffix products and multiply with the corresponding prefix product
        int suf = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= suf;
            suf *= nums[i];
        }

        return ans;
      }
    };

10 - ques : Maximum Depth of Binary Tree
sol : - class Solution {
public:
    int maxDepth(TreeNode* root) {
        // edge case 
        if(!root) return 0;
        int x = 1 + maxDepth(root -> left);
        int y = 1 + maxDepth(root -> right);
        return max(x,y);
       }
    };

11 - ques : Same Tree
sol : - class Solution {
public:
    bool isSameTree(TreeNode* r1, TreeNode* r2) {
        if(r1 == nullptr && r2 == nullptr) return 1;
        if(!r1 && r2 || r1 && !r2) return 0;
        if(r1 -> val != r2 -> val) return 0;
         return isSameTree(r1 -> left,r2 -> left) && isSameTree (r1 -> right, r2 -> right);
          }
     };

12 - ques : Count Complete Tree Nodes
sol : - class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        return ( 1 + countNodes(root -> left) + countNodes(root -> right));
    }
};
