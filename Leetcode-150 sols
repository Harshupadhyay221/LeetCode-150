## Day 1
1 - ques : Merge Sorted Array 
- sol  : class Solution {
         public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // Append elements from nums2 to nums1
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        
        // Sort the combined array
        sort(nums1.begin(), nums1.end());
        }
     };



2- ques : Remove Element
- sol : class Solution {
         public:
         int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int ans = 0;
        for(int i = 0; i < n; i++){
            if(nums[i] != val){
                nums[ans] = nums[i];
                ans++;
            }
        }
        return ans;
         }
       };


3- ques : Remove Duplicates from Sorted Array
- sol : class Solution {
        public:
        int removeDuplicates(vector<int>& nums) {
        if(nums.empty()) return 0;
        int i = 0;
        for(int j = 0; j < nums.size();j++){
            if(nums[i] != nums[j]){
                i++;
            }
            nums[i] = nums[j];
        }
        return i + 1;
       }
    };

4 - ques :Remove Duplicates from Sorted Array II
- sol : class Solution {
         public:
        int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int i = 2;
        int j = 2;
        if( n < 3) return n;
        for(int j = 2; j < n;j++){
            if(nums[j] != nums[i - 1]){
                nums[i++] = nums[j];
            }
            else if(nums[j] != nums[i - 2]){
                nums[i++] = nums[j];
            }
        }
        return i;
       }
   };

5 - ques : Majority Element
- sol : class Solution {
        public:
        int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int x = nums[0];
        int v = 1;
        for(int i =1 ; i < n; i++){
            if(nums[i] == x){
                v++;
            }
            else{
                v--;
                if(v == 0){
                    x = nums[i];
                    v++;
                }
            }
        }
        return x;
         }
       };

6 - ques : Rotate Array
- sol : class Solution {
        public:
        void reverse(vector<int>& nums,int s,int e){
        while(s < e){
            swap(nums[s++],nums[e--]);
        }
    }
    void rotate(vector<int>& nums, int k) {
        // edge case 
        k = k % nums.size();
        // revrese all
        reverse(nums,0,nums.size() - 1);
        // reverse k 
        reverse(nums,0,k - 1);
        // reverse remaining
        reverse(nums,k,nums.size() - 1);
    }
  };

7 - ques : Best Time to Buy and Sell Stock
- sol : class Solution {
         public:
         int maxProfit(vector<int>& prices) {
        int profit = 0;
        int buy = prices[0];
        int n = prices.size();
        for(int i= 1; i <n; i++){
            if(buy > prices[i]){
                buy = prices[i];
            }
            profit = max(profit,prices[i] - buy);
        }
        return profit;
    }
};


8 - ques : Best Time to Buy and Sell Stock II
sol - : class Solution {
     public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        int n = prices.size();
        
        // Loop through the price list, check for each consecutive day.
        for (int i = 0; i < n - 1; i++) {
            // If the price of the next day is greater, add the difference to the profit.
            if (prices[i + 1] > prices[i]) {
                profit += prices[i + 1] - prices[i];
            }
        }
        
        return profit;
    }
};

9 - ques : Product of Array Except Self
sol - : class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
     int n = nums.size();
     vector< int> ans(n, 1); 

        //  Calculate prefix products
        int pre = 1;
        for (int i = 0; i < n; i++) {
            ans[i] = pre;
            pre *= nums[i];
        }

        // Calculate suffix products and multiply with the corresponding prefix product
        int suf = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= suf;
            suf *= nums[i];
        }

        return ans;
      }
    };

10 - ques : Maximum Depth of Binary Tree
sol : - class Solution {
public:
    int maxDepth(TreeNode* root) {
        // edge case 
        if(!root) return 0;
        int x = 1 + maxDepth(root -> left);
        int y = 1 + maxDepth(root -> right);
        return max(x,y);
       }
    };

11 - ques : Same Tree
sol : - class Solution {
public:
    bool isSameTree(TreeNode* r1, TreeNode* r2) {
        if(r1 == nullptr && r2 == nullptr) return 1;
        if(!r1 && r2 || r1 && !r2) return 0;
        if(r1 -> val != r2 -> val) return 0;
         return isSameTree(r1 -> left,r2 -> left) && isSameTree (r1 -> right, r2 -> right);
          }
     };

12 - ques : Count Complete Tree Nodes
sol : - class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        return ( 1 + countNodes(root -> left) + countNodes(root -> right));
    }
};

13 - ques :  Jump Game
sol : -  class Solution {
          public:
          bool canJump(vector<int>& nums) {
        int n = nums.size();
        // create dp array
        vector<bool> dp(n,0);
        // handle 2 -3 base case 
        dp[0] = true;
        dp[1] = nums[0] != 0 ;0
        // fill dp array
â€¦       }
     };

14 - ques : jump Game II
sol :- class Solution {
       public:
      int jump(vector<int>& nums) {
         int n = nums.size();
        // create dp array
        vector<int> dp(n,INT_MAX);
        // handle 2 -3 base case 
        dp[0] = 0;
       if(n > 1) dp[1] = 1;
        // fill dp array
        for(int k = 2 ; k <n ; k++){
            for(int i = k - 1; i >= 0; i--){
                if(i + nums[i] >= k){
                    dp[k] = min(dp[k] ,dp[i] + 1);
                }
            }
        }
        // return last element;
        return dp[n - 1];
        }
   };


15 - ques : Roman to Integer
sol :- class Solution {
    public:
    int num(char c) {
        if (c == 'I')
            return 1;
        else if (c == 'V')
            return 5;
        else if (c == 'X')
            return 10;
        else if (c == 'L')
            return 50;
        else if (c == 'C')
            return 100;
        else if (c == 'D')
            return 500;
        else if (c == 'M')
            return 1000;
        else 
            return 0;
    }

       int romanToInt(string s) {
        int sum = 0;
        int index = 0;
        
        while (index < s.size() - 1) {
            if (num(s[index]) < num(s[index + 1])) {
                sum -= num(s[index]);
            } else {
                sum += num(s[index]);
            }
            index++;
        }
        
        // Add the value of the last character
        sum += num(s[s.size() - 1]);
        
        return sum;
    }
   };


16 : ques - Two Sum
sol : - class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        map<int , int > mp;
        for (int i = 0 ; i < n ; i++)
        {
            int rem = target - nums[i] ;
            if(mp.find(rem) != mp.end())
            {
                return {mp[rem] , i} ;
            }
            mp[nums[i]] = i ;
        }
        return {};
    }
};


17 : - Find Peak Element
sol : - class Solution {
        public:
        int findPeakElement(vector<int>& nums) {
        int l=0,h=nums.size()-1;
        while(l<h) {
            int mid=l+(h-l)/2;
            if(nums[mid]<nums[mid+1])
                l=mid+1;
            else
                h=mid;
        }
        return l;
      }
  };


18 : -  Search Insert Position
sol : - class Solution {
       public:
     int searchInsert(vector<int>& nums, int target) {
        int s = 0, e = nums.size() - 1, mid;
        while(s <= e) {
            mid = s + (e - s) / 2;
            if (nums[mid] == target) {
                return mid;
                break ;
            } else if (nums[mid] < target) {
                s = mid + 1;
            } else {
                e = mid - 1;
            }
        }
         return s; 
     }
 };

19 : - ques : Linked List Cycle
sol : - class Solution {
        public:
        bool hasCycle(ListNode *head) {
        ListNode * curr = head;
        unordered_map<ListNode* ,bool> mp;
        while(curr != nullptr){
            if(mp[curr] == 1){
                return 1;
            }
             mp[curr] = 1;
             curr = curr -> next; 
        }
        return 0;
      }
 };

20 : - ques : Merge Two Sorted Lists
sol : - class Solution {
        public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode * dummy = new ListNode(0);
        ListNode * tail = dummy;
        while(list1 && list2){
            if(list1 -> val <= list2 -> val){
                tail -> next = list1;
                list1 =  list1 -> next;
            }
            else{
                tail -> next = list2;
                list2 = list2 -> next;
            }
            tail = tail -> next;
        }
        if(list1){
            tail -> next = list1;
        }
        else{
            tail -> next = list2;
        }
        ListNode * ans = dummy -> next;
        delete dummy;
        return ans;
    }
 };


21 : ques -Average of Levels in Binary Tree
   sol : - class Solution {
           public:
           vector<double> averageOfLevels(TreeNode* root) {
           vector<double> avg;
           queue<TreeNode *> q;
          q.push(root);
        while(!q.empty())
        {
            int s = q.size();
            double sum = 0;
            for(int i= 0; i< s; i++)
            {
                TreeNode * temp = q.front();
                q.pop();
                sum += temp -> val;
                if(temp -> left)
                q.push(temp -> left);
                if(temp -> right)
                q.push(temp -> right);
            }
            avg.push_back(sum / s);
        }
        return avg;
    }
};


22 : - ques : symmetric Tree
sol : - class Solution
{
public:
    bool isEqual(TreeNode *root1, TreeNode *root2)
    {
        if (root1 && root2) // if both nodes are not null
        {
            if (root1->val == root2->val) // If siblings are same
            {
                return isEqual(root1->left, root2->right) && isEqual(root1->right, root2->left); // step two recursion part
            }
            return false;
        }
        if (!root1 && !root2) // if both are null
            return true;
        return false; // if one is null but other is not null then return false
    }

    bool isSymmetric(TreeNode *root)
    {
        return isEqual(root->left, root->right);
    }
};


23 : - ques : palindrome number
sol : - class Solution {
        public:
        bool isPalindrome(int x) {
        // Negative numbers are not palindromes
        if (x < 0) {
            return false;
        }
        
        int revnum = 0;
        int dup = x; // Store the original value of x
        
        while (x > 0) {
            int ld = x % 10;
            
            // Check for overflow before updating revnum
            if (revnum > (INT_MAX - ld) / 10) {
                return false; // Overflow would occur
            }
            
            revnum = (revnum * 10) + ld;
            x = x / 10;
        }
        
        // Compare reversed number with the original value
        return dup == revnum;
    }
};


24 : - ques : plus one
sol : -  class Solution {
public:
    vector<int> plusOne(vector<int>& v) {
        int n = v.size();
        for(int i = n-1; i >= 0; i--){
            if(i == n-1)
                v[i]++;
            if(v[i] == 10){
                v[i] = 0;
                if(i != 0){
                    v[i-1]++;
                }
                else{
                    v.push_back(0);
                    v[i] = 1;
                }
            }
        }
        return v;
    }
};
